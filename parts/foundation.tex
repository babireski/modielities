\chapter{Fundamentação}

Nesta parte do trabalho, serão apresentadas definições gerais que fundamentarão as definições mais estritas que serão apresentadas futuramente. Notadamente, fundamentaremos as noções de sistemas e traduções. Ademais, discorreremos acerca da noção de provadores, que serão usados para certificar as provas apresentadas posteriormente. Antes disso, entretanto, introduziremos duas notações que serão usadas copiosamente, uma para o conjunto das partes e outra para sucessões.

\begin{notation}
    Seja $A$ um conjunto, $\mathfrak{P}(A)$ denota o conjunto $\set{X\mid X\subseteq A}$.
\end{notation}

\begin{notation}
    Seja $i\in\mathbb{N}^+$ e $n\in\mathbb{N}$, $\sequence{a_i\mid i\leq n}$ denota uma sucessão de $n$ elementos de modo que o elemento $a_i$ encontra-se na posição $i$.
\end{notation}

\section{Sistemas}

Sistemas de dedução buscam formalizar e sistematizar o processo de razoamento. Estudos acerca disso datam da antiguidade, dentre os quais destaca-se~\cite{Aristotle}. Considera-se que os estudos modernos neste campo foram, dentre outras pessoas, fundados por~\cite{Frege} e continuados por~\cite{Russel-A,Russel-B,Russel-C}. Estas investigações --- bem como outras --- levaram ao desenvolvimento do sistema hoje tido como padrão. Posteriormente a isso, viu-se o surgimento de diversos sistemas não-padrões, fato que --- conforme~\cite{Beziau-B} --- justifica uma conceituação de sistema de dedução, que apresentaremos nesta seção.

Ainda segundo~\cite{Beziau-B}, os primeiros desenvolvimentos neste sentido foram feitos por~\cite{Tarski}, que define o conceito de dedução com base num operador de fecho $C\mathrel{:}\mathfrak{P}(\mathcal{L})\to\mathfrak{P}(\mathcal{L})$, sendo $\mathcal{L}$ um conjunto qualquer. Neste trabalho entretanto usaremos a definição proposta por~\cite{Beziau} baseada numa relação de dedução ${\vdash}\subseteq\mathfrak{P}(\mathcal{L})\times\mathcal{L}$, uma vez que, por sua simplicidade, não traz elementos irrelevantes aos intuitos deste. Cabe destacar, conforme apontam~\cite{Font}, que ambas as definições são equivalentes\footnote{Destaca-se, entretanto, que a definição de~\cite{Tarski} requer a satisfação de postulados não requeridos por~\cite{Beziau}, sendo portanto menos geralista.}, uma vez que $\Gamma\entails\alpha$ se e somente se $\alpha\in C(\Gamma)$.

\begin{definition}[Sistema]
    Um sistema de dedução consiste num par $\mathfrak{S} = \sequence{\mathcal{L}, \vdash}$, onde $\mathcal{L}$ consiste em um conjunto e ${\vdash}\subseteq\mathfrak{P}(\mathcal{L})\times\mathcal{L}$ em uma relação sobre o produto cartesiano do conjunto das partes de $\mathcal{L}$ e o conjunto $\mathcal{L}$, sem demais condições.
    \qed{}
\end{definition}

Conforme~\cite{Beziau} aponta, a qualidade e quantidade dos elementos de um sistema $\mathfrak{S}=\sequence{\mathcal{L}, \vdash}$ não são especificados, portanto sendo esta uma definição de grande generalidade. Neste sentido, com base no escopo deste trabalho, restringiremos a definição do conjunto $\mathcal{L}$ --- dito \emph{linguagem} --- a linguagens proposicionais. Os elementos destas, aos quais daremos o nome de \emph{sentenças}, notabilizam-se por serem formadas por \emph{letras} --- que consistem em proposições indivisas --- e \emph{operadores} --- que podem gerar proposições maiores a partir de proposições menores. Ao par formado por letras e operadores daremos o nome \emph{assinatura}, conforme abaixo.

\begin{definition}[Assinatura]
    Uma assinatura proposicional consiste num par $\Sigma=\sequence{\mathcal{P},\mathcal{C}}$, onde $\mathcal{P}$ consiste num conjunto letras e $\mathcal{C}=\bigcup\set{\mathcal{C}_i\mid i\in\mathbb{N}}$ num conjunto de operadores de modo que $\mathalpha{\circ}\in\mathcal{C}_n$ se e somente se $\mathalpha{\circ}$ possuir aridade $n$.
    \qed{}
\end{definition}

\begin{notation}
    Seja $\mathcal{C}$ um conjunto de operadores, $\mathalpha{\circ}^n$ denota um operador $\mathalpha{\circ}\in\mathcal{C}_n$.
\end{notation}

Podemos interpretar os conjuntos $\mathcal{P}$ e $\mathcal{C}$ de uma assinatura $\Sigma=\sequence{\mathcal{P},\mathcal{C}}$ como construtores de sentenças.
Neste sentido, o conjunto $\mathcal{C}_0$ assemelha-se mais ao conjunto $\mathcal{P}$, uma vez que seus elementos --- ditos \emph{constantes} --- não geram sentenças maiores partindo de sentenças menores.
Nota-se que uma assinatura constitui um elemento suficiente para definirmos indutivamente a linguagem de um sistema, conforme definido abaixo de maneira similar a~\cite{Franks}.
Por fim, destacamos que, para todos os sistemas apresentados neste trabalho, usaremos o conjunto de letras $\mathcal{P}=\set{p_i\mid i\in\mathbb{N}}$ e letras romanas em caixa-baixa para representar seus elementos.

\begin{definition}[Linguagem]
    Seja $\Sigma=\sequence{\mathcal{P},\mathcal{C}}$ uma assinatura proposicional. Uma linguagem proposicional $\mathcal{L}$ induzida a partir de $\Sigma$ consiste no menor conjunto de sentenças bem-formadas induzido a partir das seguintes regras:
    \begin{enumerate}[label=\textbf{\emph{(\alph*)}}, left=\parindent]
        \item$\mathcal{P}\subseteq\mathcal{L}$
        \item\text{Se }$\mathalpha{\circ}\in\mathcal{C}_n\text{ e }\set{\varphi_i\mid i\leq n}\subseteq\mathcal{L}\text{, então }\circ\sequence{\varphi_i\mid i\leq n}\in\mathcal{L}$.\qed{}
    \end{enumerate}
\end{definition}

Neste trabalho, representaremos sentenças por letras gregas em caixa-baixa e conjuntos de sentenças por letras gregas em caixa-alta.\footnote{Desconsiderando-se o $\Sigma$, usado para representar assinaturas.}
Ademais, impõe-se definir a noção de profundidade de uma sentença. Esta noção, em termos simples, consiste no comprimento do maior ramo da construção da dada sentença. A definição provida abaixo consiste numa generalização para quaisquer aridades da definição dada por~\cite{Troelstra}. Usaremos essa definição futuramente para fazer demonstrações por meio provas indutivas sobre esta propriedade.

\begin{definition}[Profundidade]
    Seja $\mathfrak{S} = \sequence{\mathcal{L}, \vdash}$ um sistema com linguagem induzida a partir de uma assinatura $\Sigma=\sequence{\mathcal{P},\mathcal{C}}$. Considerando-se uma proposição $a\in\mathcal{P}$, um operador ${\circ}\in\mathcal{C}$ e uma aridade $n>0$, definimos a profundidade $|\alpha|$ de uma sentença $\alpha\in\mathcal{L}$ indutivamente da seguinte maneira:
    \begin{align*}
        |a|&\coloneqq 0\\
        |{\circ^0}|&\coloneqq 0\\
        |{\circ^n\sequence{\varphi_i\mid i\leq n}}|&\coloneqq\max\set{|\varphi_i|\mid i\leq n}+1.
        \tag*{\qed} 
    \end{align*}
\end{definition}

Com isso, encerram-se as definições relacionadas a linguagens de sistemas de dedução. Agora, apresentaremos definições relacionadas a relações de dedução, que gozam da mesma generalidade dada a liguagens. Deste modo, a relação $\mathalpha{\vdash}$ pode ser tanto uma relação de \emph{derivação} --- definida sintaticamente --- quanto uma relação de \emph{satisfação}\footnote{Sendo esta denotada por $\mathalpha{\vDash}$.} --- definida semanticamente. Neste trabalho, serão abordados apenas sistemas definidos sobre relações de derivação. Cabe destacar, entretanto, que nada na definição de tradução impede que esta seja feita sobre relações de satisfação, conforme veremos com mais detalhes futuramente.

Neste trabalho, definiremos a relações de dedução baseada em axiomatizações, ou seja, em conjuntos de \emph{axiomas} --- sentenças postuladas como verdadeiras --- e conjuntos de \emph{regras de dedução} --- que permitem derivar mais sentenças verdadeiras caso certas condições sejam satisfeitas. Axiomatizações consistem numa abordagem hilbertiana de dedução que, segundo~\cite{Troelstra}, distinguem-se por conter um conjunto reduzido de regras de dedução que nunca descartam premissas. Ainda baseando-se em~\cite{Troelstra} e em contraste a~\cite{Frege} e~\cite{Hilbert-A, Hilbert-B}, preferiremos esquemas de axiomas a axiomas individuais de modo a eliminarmos a necessidade de instanciações.

\begin{definition}[Axiomatização]
    Seja $\mathfrak{S}=\sequence{\mathcal{L},\vdash}$ um sistema. Uma axiomatização para o sistema $\mathfrak{S}$ consiste num par $\mathcal{H}=\sequence{\mathcal{A},\mathcal{R}}$, sendo $\mathcal{A}$ um conjunto de esquemas de axiomas e $\mathcal{R}$ um conjunto de regras de dedução.
\end{definition}

\begin{definition}[Dedução]
    Seja um sistema $\mathfrak{S} = \sequence{\mathcal{L},{\vdash}}$ com uma relação de dedução definida sobre uma axiomatização $\mathcal{H} = \sequence{\mathcal{A},\mathcal{R}}$ e  seja um conjunto de sentenças $\Gamma\cup\set{\alpha}\subseteq\mathcal{L}$.
    A dedução $\Gamma\vdash\alpha$ vale se e somente se houver sucessão de sentenças $\sequence{\varphi_i\in\mathcal{L}\mid i\leq n}$ de modo que $\varphi_n=\alpha$ e que cada sentença $\varphi_i$ tenha sido gerada ou por algum esquema $\mathbf{A}\in\mathcal{A}$ ou pela aplicação de alguma regra $\mathbf{R}\in\mathcal{R}$ a sentenças anteriores.
    \qed{}
\end{definition}

\section{Traduções}

Traduções entre sistemas consistem em funções que mapeiam sentenças de um sistema a sentenças de outro, garantindo certas propriedades. As propriedades a serem garantidas variam e ainda são discutidas na literatura, deixando que a definição exata de tradução --- assim como houve com a definição de sistema --- varie de acordo com a predileção e as necessidades de cada autor. Nesta seção, serão abordadas historicamente noções de tradução entre sistemas, bem como serão definidos e nomeados os conceitos de tradução que serão usados no restante deste trabalho.

\begin{definition}[Condições]
    Chamaremos a condição $\varnothing\entails_\mathbf{A}\alpha$ implica em $\varnothing\entails_\mathbf{B}\alpha^*$ de correção fraca e a condição $\varnothing\entails_\mathbf{B}\alpha^*$ implica em $\varnothing\entails_\mathbf{A}\alpha$ de completude fraca. Analogamente, considerando-se dedução com premissas, chamaremos a condição $\Gamma\entails_\mathbf{A}\alpha$ implica em $\Gamma^*\entails_\mathbf{B}\alpha^*$ de correção forte e a condição $\Gamma^*\entails_\mathbf{B}\alpha^*$ implica em $\Gamma\entails_\mathbf{A}\alpha$ de completude forte.
\end{definition}

Historicamente, autores usaram diferentes combinações das condições apresentadas acima e, em certos casos, outras. Neste trabalho, adotaremos uma noção forte de tradução que requer tanto a correção forte quanto a completude forte, conforme~\cite{Coniglio}. Definiremos, ainda, uma notação que nos permite aplicar sucintamente a tradução a todos os elementos de um conjunto.

\begin{definition}[Tradução] 
    Uma sentença $\varphi$ de um sistema $\mathfrak{A} = \langle\mathcal{A}, \vdash_\mathfrak{A}\rangle$ pode ser traduzida a uma sentença $\varphi^*$ em um sistema $\mathfrak{B} = \langle\mathcal{B}, \vdash_\mathfrak{B} \rangle$ caso exista uma função $\bullet^* : \mathcal{A} \to \mathcal{B}$ que garanta que $\Gamma\vdash_\mathfrak{A}\varphi$ se e somente se $\Gamma^*\vdash_\mathfrak{B}\varphi^*$.
    \qed{}
\end{definition}

\begin{notation}
    Seja $\Gamma\in\mathfrak{P}(\mathcal{A})$ um conjunto de sentenças bem-formadas e $\bullet^*\mathrel{:}\mathcal{A}\to\mathcal{B}$ uma tradução. $\Gamma^*$ denota o conjunto $\set{\alpha^*\mid\alpha\in\Gamma}\in\mathfrak{P}(\mathcal{B})$, ou seja, a aplicação da tradução a todos os elementos do conjunto $\Gamma$.
    \qed{}
\end{notation}

A primeira tradução entre dois sistemas conhecida na literatura foi definida por~\cite{Kolmogorov} como uma maneira de demonstrar que o uso da \emph{lei do terceiro excluso}\footnote{Definido como $\entails\alpha\vee\neg\alpha$.} não leva a contradições. Essa definição consiste basicamente em prefixar uma dupla negação a cada elemento da construção de uma dada sentença \citep{Coniglio}, motivo pelo qual chamaremos essa tradução de \emph{tradução de negação dupla}. Essa mesma tradução foi também descoberta independentemente por Gödel e por Getzen. Curiosamente, essa tradução mostra-se relevante para o escopo deste trabalho, uma vez que consiste na contraparte da passagem por continuações segundo a interpretação prova-programa.

\begin{example} Define-se a tradução $\bullet^\neg:\mathcal{L}_\mathbf{C}\to\mathcal{L}_\mathbf{I}$ do sistema clássico ao sistema intuicionista indutivamente da seguinte maneira:
    \begin{align*}
        p^\neg&\coloneqq\neg\neg p\\
        \bot^\neg&\coloneqq\bot\\
        {(\varphi\wedge\psi)}^\neg&\coloneqq\neg\neg(\varphi^\neg \wedge \psi^\neg)\\
        {(\varphi\vee\psi)}^\neg&\coloneqq\neg\neg (\varphi^\neg \vee \psi^\neg)\\
        {(\varphi\to\psi)}^\neg&\coloneqq\neg\neg (\varphi^\neg \to \psi^\neg)
        \tag*{\qed} 
    \end{align*}
\end{example}

\section{Provadores}

A primeira prova de destaque a ser realizada com grande uso de computadores foi a do teorema das quatro cores\footnote{Que afirma que \emph{qualquer mapa planar tem uma quatro-coloração}.}, feita por~\cite{Appel}, motivado pela grande quantidade de casos a serem analisados. Conforme~\cite{Wilson} afirma, esta prova foi, por uns, recebida com entusiasmo e por outros, devido ao uso de computadores, com cetistismo e desapontamento. Dentre aqueles que compartilharam destas visões opositoras, destaca-se~\cite{Tymoczko}. Ainda segundo~\cite{Wilson}, o teorema tornou-se mais aceito com o passar do tempo e foi, posteriormente, formalizado em um provador de teoremas por~\cite{Gonthier}.

Provadores de teoremas consistem em programas de computador que verificam a validade de teoremas. Dentre estes, podemos destacar as classes dos provadores \emph{automáticos} e dos provadores \emph{interativos}. Os primeiros buscam provar teoremas de maneira que requeira a menor quantidade de intervenção humana, enquanto os segundos --- que ganharam destaque depois das limitações dos primeiros ficarem evidentes --- delegam-se a verificar rigorosamente provas desenvolvidas por humanos em sua linguagem. Formalizaremos as provas apresentadas neste trabalho no provador de teoremas interativo \textsc{coq}, o mesmo \emph{software} usado por~\cite{Gonthier}.

O \textsc{coq} trata-se de um provador de teoremas interativo baseado no \emph{cálculo de construções}. Este sistema formal fornece uma estrutura unificada para definir funções, tipos e proposições, permitindo a construção e verificação de provas dentro do mesmo formalismo. No \textsc{coq}, entretanto, este formalismo foi estendido de modo a permitir tipos indutivos, criando o dito \emph{cálculo de construções indutivas}. Neste, pode-se definir tipos de dados estruturados e funções e provas recursivas. Essa fundação alinha-se com isomorfismo de Curry-Howard, onde programas correspondem a provas e tipos correspondem a proposições, tornando o \textsc{coq} uma ferramenta poderosa de formalização e verificação. Para um maior aprofundamento acerca do provador de teoremas \textsc{coq}, recomenda-se a leitura de~\cite{Chlipala},~\cite{Pierce} e~\cite{Coq}.
