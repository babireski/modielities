\chapter{Introdução}

As lógicas modais consistem em um conjunto de extensões da lógica clássica que contam com a adição de um ou mais operadores, chamados modalidades, que qualificam sentenças. No caso do sistema \textbf{S4}, são adicionadas as modalidades de necessidade ($\nec$) e possibilidade ($\pos$) em conjunto à regra da necessitação\footnote{Se $\vdash A$ então $\vdash \nec A$} e os axiomas $\text{\textbf{K}: } \nec(A \to B) \to \nec A \to \nec B$, $\text{\textbf{T}: } \nec A \to A$ e $\text{\textbf{4}: } \nec A \to \nec \nec A$ \cite{Troelstra}. Ademais, pode-se derivar nesse sistema, por meio da dualidade entre as modalidades\footnote{$\pos A \equiv \neg \nec \neg A $}, sentenças duais aos axiomas \textbf{T} e \textbf{4}, sendo elas $\boldsymbol{\text{\textbf{T}}_\pos \text{: }} A \to \pos A$ e $\boldsymbol{\text{\textbf{4}}_\pos \text{: }} \pos \pos A \to \pos A$, respectivamente \cite{Zach}.

As mônadas ganharam destaque na área de linguagens de programação desde que \cite{Moggi} formalizou uma metalinguagem que faz uso dessas estruturas para modelar noções de computação -- como parcialidade, não-determinismo, exceções e continuações -- de uma maneira puramente funcional. Pode-se notar uma grande semelhança entre as sentenças $\boldsymbol{\text{\textbf{T}}_\pos}$ e $\boldsymbol{\text{\textbf{4}}_\pos}$ e as transformações naturais monádicas $\boldsymbol{\eta \text{: }} 1_C \to T$ e $\boldsymbol{\mu \text{: }} T^2 \to T$, respectivamente. Nesse sentido, \cite{Pfenning} demonstraram que se pode traduzir essa metalinguagem para o sistema \textbf{S4} da lógica modal, pelo qual se torna interessante analisar esse sistema como uma linguagem de programação sob a ótica do isomorfismo de Curry-Howard.

\cite{Troelstra} apresentam duas traduções equivalentes da lógica intuicionista para o sistema \textbf{S4} da lógica modal, sendo um deles correspondente a uma abordagem \textit{call-by-name} e outra a um abordagem \textit{call-by-value}. Tais traduções possuem grande similaridade com as traduções da lógica intuicionista para a lógica linear definidas por \cite{Girard}. Essas traduções equivalem à tradução por negação dupla que, por sua vez, equivalem a traduções \textit{continuation-passing style} (CPS) em compiladores por meio do isomorfismo de Curry-Howard \cite{Reynolds}, o que torna esse tema interessante no ponto de vista de compilação.

Durante grande parte da história, provas lógicas e matemáticas eram validadas manualmente pela comunidade acadêmica, o que muitas vezes -- a depender do tamanho e complexidade da prova -- se mostrava ser um trabalho complexo e sujeito a erros. Hoje em dia, exitem \textit{softwares} chamados assistentes de provas que permitem verificar -- graças ao isomorfismo de Curry-Howard -- a corretude de provas \cite{Chlipala}. O assistente de provas que será usado neste trabalho é o Coq, que utiliza o cálculo de construções indutivas e um conjunto axiomático pequeno para permitir a escrita de provas simples e intuitivas \cite{Barras}.

Este trabalho será uma continuação do desenvolvimento da biblioteca de lógica modal no assistente de provas Coq feito em \cite{Silveira} e posteriormente expandido de forma a permitir a fusão de lógicas modais em \cite{Nunes}. Uma formalização similar de traduções de lógicas foi feito em \cite{Sehnem}, porém, neste caso, das lógicas clássica e intuicionista para a lógica linear.

    \section{Justificativa}
    \section{Metas}
    \section{Estruturação}